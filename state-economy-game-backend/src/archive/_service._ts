import { NextFunction, Request, Response } from "express";
import { randomUUID } from "crypto";
import { Op, DataTypes, Sequelize, Model } from "sequelize";

import {
  StateRecord,
  GameId,
  GuessSubmissionResponse,
  GuessSubmissionRequest,
  PuzzleAnswerResponse,
} from "state-economy-game-util/model";
import {
  getHaversineDistance,
  getHaversineBearing,
  isStateNameValid,
  getUsStateRecords,
} from "state-economy-game-util/util";
import { CheckedHttpError } from "state-economy-game-util/model";
import { MAX_GUESSES } from "state-economy-game-util/constants";
import { GameIdModel, TargetStateModel } from "./persistentModel";

export default class Service {

  sequelize: Sequelize 
  constructor(sequelize: Sequelize) {
    this.sequelize = sequelize;
    GameIdModel.init(
      {
        id: { type: DataTypes.STRING, primaryKey: true },
        attempts: DataTypes.INTEGER,
      },
      {
        tableName: "GameIds",
        sequelize,
        timestamps: true,
      }
    );

    TargetStateModel.init(
      {
        id: { type: DataTypes.INTEGER, primaryKey: true },
        targetStateName: DataTypes.STRING,
      },
      {
        tableName: "TargetStateName",
        sequelize,
        timestamps: true
      }
    );
  }

  public async getTargetStateRecord() {
    return StateRecord.of(await this.getTargetStateName());
  }

  public async postGameId(_req: Request, res: Response) {
    const newUUID = randomUUID();
    const gameId: GameId = await GameIdModel.create({
      id: newUUID,
      attempts: 0,
    });
    res.status(201).json(gameId);
  }

  //TODO: determine which state-economy-game-util methods/data should no longer be there for security/cheating purposes
  public async getTargetStateEconomy(_req: Request, res: Response) {
    const record = await this.getTargetStateRecord();
    res.status(200).json(record.economy);
  }

  public async postGuessSubmission(req: Request, res: Response, next: NextFunction) {
    const { id, guessStateName } = req.body as GuessSubmissionRequest;
    if (!id || !guessStateName) {
      return next(CheckedHttpError.of("Request must contain both a game id and a guess state name", 400));
    }
    const gameId = await GameIdModel.findOne({ where: { id: id } });
    if (!isStateNameValid(guessStateName) || !gameId) {
      return next(CheckedHttpError.of("Game id and a guess state name must both be valid", 422));
    } else if (gameId.attempts >= MAX_GUESSES) {
      return next(CheckedHttpError.of("Too many request have been made for this game", 422));
    }

    const responseBody: GuessSubmissionResponse = {
      id: id,
      distance: getHaversineDistance(StateRecord.of(guessStateName), await this.getTargetStateRecord()),
      bearing: getHaversineBearing(StateRecord.of(guessStateName), await this.getTargetStateRecord()),
    };

    //@ts-ignore
    await GameIdModel.update({ attempts: gameId.attempts + 1 }, { where: { id: id } });
    res.status(201).json(responseBody);
  }

  public async getPuzzleAnswer(req: Request, res: Response, next: NextFunction) {
    const id = req.params.id;
    if (!id) {
      return next(CheckedHttpError.of("Request must contain a game id", 400));
    }

    const gameId = await GameIdModel.findOne({ where: { id: id } });
    if (!gameId) {
      return next(CheckedHttpError.of("Game id must be valid", 422));
    } else if (gameId?.attempts < MAX_GUESSES) {
      return next(CheckedHttpError.of(`${MAX_GUESSES} guesses must be made before answer can be requested`, 422));
    }
    const record = await this.getTargetStateRecord();
    const responseBody: PuzzleAnswerResponse = {
      id: id,
      targetStateName: record.name,
    };
    res.status(200).json(responseBody);
  }

  public getHealthCheck(_req: Request, res: Response) {
    return res.status(200).json({ status: "UP" });
  }

  public handleErrors(err: Error, req: Request, res: Response, next: NextFunction) {
    if (err instanceof CheckedHttpError) {
      res.status(err.httpCode).json({ message: err.message });
    } else {
      console.log(res);
      res.status(500).json({ message: "HTTP response code 500: server error" });
    }
  }

  public handleUnhandledRoute(req: Request, res: Response) {
    res.status(404).json({ message: "HTTP response code 404: route not handled" });
  }

  public async getTargetStateName() {
    const targetStateModel = await TargetStateModel.findOne();
    if (!targetStateModel) throw new Error("Targetstate not found");
    return targetStateModel.targetStateName;
  }

  public async runDailyTasks() {
    const obsoleteDate = new Date();
    obsoleteDate.setDate(obsoleteDate.getDate() - 1);

    await GameIdModel.destroy({
      where: {
        createdAt: {
          [Op.lt]: obsoleteDate,
        },
      },
    });
    await TargetStateModel.destroy({ truncate: true });

    const newTargetState = getUsStateRecords().at(this.getRandomInt(getUsStateRecords().length));

    await TargetStateModel.create({
      id: 1,
      targetStateName: newTargetState?.name,
    });
  }

  getRandomInt(max: number) {
    return Math.floor(Math.random() * max);
  }
}
