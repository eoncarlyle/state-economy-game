import express, { Express, NextFunction, Request, Response } from "express";
import { randomUUID } from "crypto";
import cors from "cors";
import cron from "cron"

import {
  StateRecord,
  GameId,
  GuessSubmissionResponse,
  GuessSubmissionRequest,
  PuzzleAnswerRequest,
  PuzzleAnswerResponse,
} from "state-economy-game-util/model";
import { GameIdModel } from "./persistentModel";
import { getHaversineDistance, getHaversineBearing, isStateNameValid, getUsStateRecord } from "state-economy-game-util/util";
import { CheckedHttpError } from "state-economy-game-util/model";
import { MAX_GUESSES } from "state-economy-game-util/constants";

const app: Express = express();

const port = process.env.PORT || 3000;


//TODO rename ID something more meaningful, but mainain this for now
//CREATE TABLE GameIds (id varchar(36) PRIMARY KEY, attempts tinyint, createdAt datetime, updatedAt datetime);

app.use(express.json());

//TODO add rotating targetStateRecord 
const getTargetStateName = () => "Oregon"

//TODO remove day + old timestamps
const getTargetStateRecord = () => StateRecord.of(getTargetStateName());

  //TODO add rotating targetStateRecord 

const postGameId = async (_req: Request, res: Response) => {
  const newUUID = randomUUID();
  const gameId: GameId = await GameIdModel.create({
    id: newUUID,
    attempts: 0,
  });
  res.status(201).json(gameId);
};

//TODO: determine which state-economy-game-util methods/data should no longer be there for security/cheating purposes
const getTargetStateEconomy = async (_req: Request, res: Response) => {
  res.status(200).json(getTargetStateRecord().economy)
}

const postGuessSubmission = async (req: Request, res: Response, next: NextFunction) => {
  const { id, guessStateName } = req.body as GuessSubmissionRequest;
  if (!id || !guessStateName){ 
    return next(CheckedHttpError.of('Request must contain both a game id and a guess state name', 400))
  }
  const gameId = await GameIdModel.findOne({ where: { id: id } })
  if (!isStateNameValid(guessStateName) || !gameId) {
    return next(CheckedHttpError.of('Game id and a guess state name must both be valid', 422))
  } else if (gameId.attempts >= MAX_GUESSES) {
    return next(CheckedHttpError.of('Too many request have been made for this game', 422))
  }

  const responseBody: GuessSubmissionResponse = {
    id: id,
    distance: getHaversineDistance(StateRecord.of(guessStateName), getTargetStateRecord()),
    bearing: getHaversineBearing(StateRecord.of(guessStateName), getTargetStateRecord()),
  }
 
  //@ts-ignore
  await GameIdModel.update({ attempts:  gameId.attempts +1 }, { where: { id: id} }) 
  res.status(201).json(responseBody);
};

const getPuzzleAnswer = async (req: Request, res: Response, next: NextFunction) => {
  const id = req.params.id
  if (!id) { 
    return next(CheckedHttpError.of('Request must contain a game id', 400));
  }
  
  const gameId = await GameIdModel.findOne({ where: { id: id } })
  if (!gameId) {
    return next(CheckedHttpError.of('Game id must be valid', 422));
  } else if (gameId?.attempts < MAX_GUESSES) {
    return next(CheckedHttpError.of(`${MAX_GUESSES} guesses must be made before answer can be requested`, 422));
  }

  const responseBody: PuzzleAnswerResponse = {
    id: id,
    targetStateName: getTargetStateRecord().name
  }
  res.status(200).json(responseBody)
}

const getHealthCheck = (_req: Request, res: Response) => {
  return res.status(200).json({status: "UP" })
}

const handleErrors = (err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof CheckedHttpError) {
    res.status(err.httpCode).json({ message: err.message })
  } else {
    console.log(res)
    res.status(500).json({ message: 'HTTP response code 500: server error' })
  }
}

const handleUnhandledRoute = (req: Request, res: Response) => {
  res.status(404).json({message: 'HTTP response code 404: route not handled'})
}

app.use(cors())

app.post("/gameId", postGameId);
app.post("/guess", postGuessSubmission)
app.get("/answer/:id", getPuzzleAnswer)
app.get("/economy", getTargetStateEconomy)
app.get("/health", getHealthCheck) 

app.use(handleErrors)
app.use(handleUnhandledRoute)

app.listen(port, () => {
  console.log(`[server]: Server is running at http://localhost:${port}`);
});
